# 购币交易
购币交易的场景主要由钱包后端和交易所服务器的接口交互实现。(流程图仍不完善！！)
![](/img/buy.png)

## 购币功能逻辑
- 1，在新建/加载钱包之后，调用 ELGamal 算法生成用户的公私钥信息（如果本地中已经有了公私钥文件，则不再生成），也可以使用导入本地存储的公私钥文件。
- 2，点击购币交易按钮，即可进入购币界面，输入用户公钥`h`和购币金额`amount`。
- 3，提交购币请求（此时调用交易所服务器），若交易所判断用户公钥`h`和购币金额`amount`合法，则将用户公钥`h`发送给监管者进行注册验证，并生成监管者公钥对本次交易的承诺`cmv`和随机数`r`，返回给前端，即购币的交易结果界面呈现一条记录，它的格式是承诺`cmv`和随机数`r`的密文。
  

## 接口
交易所服务器提供接口 `/buy [POST]` ，端口号缺省：`1323`，用户输入样例如下：

```
{
	"g1"    :"9434010866557883432899515512338590271408819035691331775356172679296704297442",
	"g2"    :"16699476090444326034784401952324371377720017398258844087346247796127238764048",
	"p"     :"22462061785371779578762224547786669348890858038353012248859154063999614739741",
	"h"     :"1041504820361995665122100729363779110602830339300272239819296520183869996060",
	"amount": "123"
}
```
- g1：pubkey，一般保持相同
- g2：pubkey，一般保持相同
- g3：pubkey，一般保持相同
- h：user_pubkey，后端调用 ELGamal 算法生成用户公钥
- amount：代表金钱数，即购币金额

设置路由 `/pubpub` 暴露给用户，返回发行者公钥信息。

## ELGamal 算法
用户新建钱包时，要从监管者处获取G1, G2, P ，并用此数据生成用户的公私钥，私钥要发给用户让他保存好。调用 `GenerateKeys` 函数，生成 `G1`、`G2`、`P` 公钥文件，计算出用户公钥 `H`。
```golang
func GenerateKeys(G1, G2, P *big.Int) (pub PublicKey, priv PrivateKey, err error) {
	//赋值
	priv.P = P	
	priv.G1 = G1	
	priv.G2 = G2

	// 随机选择私钥 X
	priv.X =new(big.Int)
	rnd := rand.New(rand.NewSource(time.Now().UnixNano()))
	priv.X.Rand(rnd, pub.P)

	// 计算用户公钥 H
	pub.H = new(big.Int)
	pub.H.Exp(pub.G2, priv.X, pub.P)
	priv.H =  pub.H

	return
}
```
